# This module makes classes for storing a configuration of the randomizer.
# Each module of the randomizer will get passed the GameConfig object and the
# flags and update the GameConfig.  Then, the randomizer will write the
# GameConfig out to the rom.
from __future__ import annotations
import dataclasses
from typing import Optional, Union

from treasures import treasuretypes
from characters import ctpcstats, pcrecruit
from shops import shoptypes

import objectivetypes as obtypes
import bossrandotypes as rotypes
import bossrandoevent as bossrando
import enemyai
import enemytechdb
import enemystats
import itemdata
import logictypes
import ctenums
import ctrom
import ctstrings
import techdb


@dataclasses.dataclass
class TabStats:
    power_tab_amt: int = 1
    magic_tab_amt: int = 1
    speed_tab_amt: int = 1


class RandoConfig:
    '''
    RandoConfig is a class which stores all of the data needed to write out
    a randomized rom.
    '''
    def __init__(
            self,
            treasure_assign_dict: Optional[
                dict[ctenums.TreasureID, treasuretypes.Treasure]
            ] = None,
            char_assign_dict: Optional[
                dict[ctenums.RecruitID, pcrecruit.RecruitSpot]
            ] = None,
            pcstats: Optional[ctpcstats.PCStatsManager] = None,
            tech_db: Optional[techdb.TechDB] = None,
            item_db: Optional[itemdata.ItemDB] = None,
            enemy_dict: Optional[
                dict[ctenums.EnemyID, enemystats.EnemyStats]
            ] = None,
            enemy_sprite_dict: Optional[
                dict[ctenums.EnemyID, enemystats.EnemySpriteData]
            ] = None,
            enemy_atk_db: Optional[enemytechdb.EnemyAttackDB] = None,
            enemy_ai_db: Optional[enemyai.EnemyAIDB] = None,
            boss_assign_dict: Optional[
                dict[rotypes.BossSpotID, rotypes.BossID]
            ] = None,
            boss_data_dict: Optional[
                dict[rotypes.BossID, rotypes.BossScheme]
            ] = None,
            tab_stats: Optional[TabStats] = None,
            omen_elevator_fights_up: Optional[list[int]] = None,  # 0,1,2
            omen_elevator_fights_down: Optional[list[int]] = None,
            # stuff that's getting replaced
            shop_manager: Optional[shoptypes.ShopManager] = None,
            boss_rank_dict: Optional[dict[rotypes.BossID, int]] = None,
            key_item_locations: Optional[
                list[Union[logictypes.Location, logictypes.LinkedLocation]]
            ] = None,
            objectives: Optional[list[obtypes.Objective]] = None
    ):
        '''
        A RandoConfig consists of the following elements:
        - treasure_assign_dict:  Mapping of TreasureIDs to Treasure Objects
        - char_assign_dict:  Mapping of CharIDs to RecruitSpot Objects
        - pcstats: Stat data for all player characters (incl. DC)
        - tech_db: Tech data for all player characters
        - enemy_dict: Stat data for all enemies
        - enemy_sprite_dict: Sprite data for all enemies
        - enemy_atk_db: Attack/Tech data for all enemies
        - boss_assign_dict: Mapping of BossSpot (LocID?) to BossID
        - boss_data_dict: Mapping of BossID to the parts/layout of each boss.
        - tab_stats: magnitude of each tab effect
        - item_db: Holds all item data
              TODO: store the tab stats in the item_db instead.  By default, CT
                    ignores item data for tabs and uses hard-coded values.
        - omen_elevator_fights_up/down: Which fights one encounters on the
              Black Omen elevators.  These should be a container with the
              values 0, 1, and 2 present to indicate that a fight is taken.
        - shop_manager: Stores all items sold by all shops.
        - boss_rank_dict: Stores the rank of each boss according to the
              boss scaling (b) flag.  This doesn't need to be here except for
              spoiler purposes.  Writing to this has no effect on the final
              rom output.
        - key_item_locations: Stores the logictypes.Location objects where
              key items are.  This is like boss_rank_dict in that it's not
              a part of the rom output.  It's just information generated by
              the logic that gets merged into the treasure_assign_dict.
        - objectives: A container to store the objectives to be used.
        Notes:
        - boss_rank_dict and key_item_locations are on the chopping block b/c
          they should be recomputable given the other items of the config.
        - There's coupling between pcstats and tech_db.  The DC assignment
          given in pcstats gives rise to a particular tech_db.  The changes
          made are destructive (no Cronos -> no Crono tech data in tech_db).
          So once pcstats has been used to compute the tech_db, then you can
          not make changes to the DC assignment.
        '''

        # Parameters are all optional now, so we need to assign defaults.
        if treasure_assign_dict is None:
            treasure_assign_dict = {}
        self.treasure_assign_dict = treasure_assign_dict

        if char_assign_dict is None:
            char_assign_dict = {}
        self.char_assign_dict = char_assign_dict

        if pcstats is None:
            pcstats = ctpcstats.PCStatsManager()
        self.pcstats = pcstats

        if tech_db is None:
            tech_db = techdb.TechDB()
        self.tech_db = tech_db

        if item_db is None:
            item_db = itemdata.ItemDB()
        self.item_db = item_db

        if enemy_dict is None:
            enemy_dict = {}
        self.enemy_dict = enemy_dict

        if enemy_sprite_dict is None:
            enemy_sprite_dict = {}
        self.enemy_sprite_dict = enemy_sprite_dict

        if enemy_atk_db is None:
            enemy_atk_db = enemytechdb.EnemyAttackDB()
        self.enemy_atk_db = enemy_atk_db

        if enemy_ai_db is None:
            enemy_ai_db = enemyai.EnemyAIDB()
        self.enemy_ai_db = enemy_ai_db

        if boss_assign_dict is None:
            boss_assign_dict = {}
        self.boss_assign_dict = boss_assign_dict

        if boss_data_dict is None:
            boss_data_dict = {}
        self.boss_data_dict = boss_data_dict

        if tab_stats is None:
            tab_stats = TabStats(1, 1, 1)
        self.tab_stats = tab_stats

        if omen_elevator_fights_down is None:
            omen_elevator_fights_down = []
        self.omen_elevator_fights_down = omen_elevator_fights_down

        if omen_elevator_fights_up is None:
            omen_elevator_fights_up = []
        self.omen_elevator_fights_up = omen_elevator_fights_up

        # stuff that's getting replaced possibly
        if shop_manager is None:
            shop_manager = shoptypes.ShopManager()
        self.shop_manager = shop_manager

        if boss_rank_dict is None:
            boss_rank_dict = {}
        self.boss_rank_dict = boss_rank_dict

        if key_item_locations is None:
            key_item_locations = []
        self.key_item_locations = key_item_locations

        if objectives is None:
            objectives = []
        self.objectives = objectives

    def to_jot_json(self):
        def enum_key_dict(d):
            "Properly uses str(key) for dicts with StrIntEnum keys."
            return { str(k): v for (k,v) in d.items() }

        def merged_list_dict(l):
            """For things that are a list of objects, each having a to_jot_json
            method that returns a single-key dict, this merges those dicts into
            one."""
            return {k: v for d in l for k, v in d.to_jot_json().items()}

        def enum_enum_dict(d):
            "For dicts with both keys and values that are StrIntEnums"
            return { str(k): str(v) for (k,v) in d.items() }

        # make boss details dict
        # stats can be gotten from the enemies dict
        BossID = rotypes.BossID
        boss_ids = list(self.boss_assign_dict.values()) + \
            [BossID.MAGUS, BossID.BLACK_TYRANO, BossID.LAVOS_SHELL,
             BossID.INNER_LAVOS, BossID.LAVOS_CORE, BossID.MAMMON_M,
             BossID.ZEAL, BossID.ZEAL_2]
        boss_details_dict = {
            str(boss_id): {
                'scale': self.boss_rank_dict.get(boss_id, None),
                'parts': [str(part.enemy_id)
                          for part in self.boss_data_dict[boss_id].parts]
            }
            for boss_id in boss_ids
        }

        boss_details_dict[str(BossID.MAGUS)]['character'] = \
            self.enemy_dict[ctenums.EnemyID.MAGUS].name.strip()

        boss_details_dict[str(BossID.BLACK_TYRANO)]['element'] = \
            str(bossrando.get_black_tyrano_element(self))

        chars = self.pcstats.to_jot_json()
        # the below is ugly, would be nice to have tech lists on PlayerChar
        # objects maybe
        def get_tech_list(char_id: int, tech_db: techdb.TechDB):
            ret_names = [
                str(ctstrings.CTNameString(tech_db.get_tech(ind)['name']))
                .strip(' *')
                for ind in range(1+char_id*8, 1+(char_id+1)*8)
            ]
            return ret_names

        for char_id in range(7):
            chars[str(ctenums.CharID(char_id))]['techs'] = \
                get_tech_list(char_id, self.tech_db)

        obstacle = self.enemy_atk_db.get_tech(0x58)
        obstacle_status = ", ".join(
            str(x) for x in obstacle.effect.status_effect)

        return {
            'key_items': merged_list_dict(self.key_item_locations),
            'characters': {
                'locations': enum_key_dict(self.char_assign_dict),
                'details': chars
            },
            'enemies': {
                'details': enum_key_dict(self.enemy_dict),
                # The boss in the twin golem spot will always be "Twin Boss"
                # This can still be looked up in the boss details and enemy
                # details structures, the latter of which can provide its name.
                'bosses': {
                    'locations': enum_enum_dict(self.boss_assign_dict),
                    'details': boss_details_dict,
                },
                'obstacle_status': obstacle_status
            },
            'treasures': {
                'assignments': enum_key_dict(self.treasure_assign_dict),
                'tabs': {
                    'power': self.tab_stats.power_tab_amt,
                    'magic': self.tab_stats.magic_tab_amt,
                    'speed': self.tab_stats.speed_tab_amt
                }
            },
            'shops': self.shop_manager,
            'items': self.item_db
        }

    # It's actually not feasible to generate one of these entirely from
    # a rom.
    #   - boss_rank_dict is hard to recover because you can't quickly
    #     compute rank from stats.  Enemy difficulty and RO complicate it.
    #   - boss_data_dict is hard to recover, especially in the annoying
    #     case of SoS having variable flame counts.
    #   - boss_assign_dict is hard to recvoer because in theory the BossID
    #     to Boss relationship can change (Guardian with Flea bits please)
    # All of the components that have from_ctrom methods can be used
    # independently.  It's ok to lump all of those together in one method.
    def update_from_ct_rom(self, ct_rom: ctrom.CTRom):
        '''
        Uses the data on the ct_rom to update the parts of the config that can
        be read easily from the rom: enemy_dict, itemdb, pcstats, tech_db,
          enemy_ai_db, enemy_atk_db, shop_manager.
        '''
        rom_data = ct_rom.rom_data  # Some types work on bytearrays
        self.enemy_dict = enemystats.get_stat_dict_from_ctrom(ct_rom)
        self.enemy_sprite_dict = enemystats.get_sprite_dict_from_ctrom(ct_rom)
        self.item_db = itemdata.ItemDB.from_rom(rom_data.getbuffer())
        self.pcstats = ctpcstats.PCStatsManager.from_ctrom(ct_rom)
        self.tech_db = techdb.TechDB.get_default_db(rom_data.getbuffer())
        self.enemy_ai_db = enemyai.EnemyAIDB.from_ctrom(ct_rom)
        self.enemy_atk_db = enemytechdb.EnemyAttackDB.from_rom(
            rom_data.getbuffer()
        )
        self.shop_manager = shoptypes.ShopManager(rom_data.getbuffer())
